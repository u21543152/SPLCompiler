package parser;

import com.splcompiler.lexer.Token;
import com.splcompiler.parser.*;
import com.splcompiler.symboltable.*;
import com.splcompiler.symboltable.SymbolTable.Symbol;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ParserTest {
	static SymbolTable tableTest = new SymbolTable();
	
    public static void main(String[] args) throws IOException {
    	List<innerNode> innerNodes = new ArrayList<>();
        List<leafNode> leafNodes = new ArrayList<>();

        // Step 1: Read tokens from the XML file
        String lexerOutputFile = "src/main/resources/output.xml";  // This is the XML file generated by the lexer
        List<Token> tokens = lexerXMLParser.readTokensFromXML(lexerOutputFile);

        // Step 2: Parse the tokens to create an AST
        parser parser = new parser(tokens);
        rootNode root = parser.parseProgram();
        System.out.println(root.toXML());
        for (Node child : root.children)
        {
            categorizeNodes(child,innerNodes,leafNodes);
        }

        writeTreeToXML("src/main/resources/syntax_tree.xml",root,innerNodes,leafNodes);
        System.out.println("syntax_tree.xml has been created!");

        // Step 2: Generate DOT file to visualize
        FileWriter writer = new FileWriter("src/main/resources/syntax_tree.dot");

        // Step 3: Write DOT format structure
        writer.write("digraph SyntaxTree {\n");
        generateDOT(root, writer);
        writer.write("}\n");

        writer.close();

        System.out.println("DOT file created! Visualize with Graphviz.");
        
        
        //test symbol table
        symboliseNodes(root);
        tableTest.printTable();
    }

    private static void writeTreeToXML(String filePath, rootNode root, List<innerNode> innerNodes, List<leafNode> leafNodes) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
            writer.write(root.toXML());
            writer.write("<INNERNODES>\n");
            for (innerNode node: innerNodes) {
                writer.write(node.toXML());
            }
            writer.write("</INNERNODES>\n");
            writer.write("<LEAFNODES>\n");
            for (leafNode node: leafNodes) {
                writer.write(node.toXML());
            }
            writer.write("</LEAFNODES>\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // Example method to generate the DOT structure
    public static void generateDOT(Node node, FileWriter writer) throws IOException {
        // Write the node's information
        writer.write(node.Unid + " [label=\"" + node.Symbol + "\"];\n");

        // Check if the node has children, write the edges, and recurse for each child
        if (node instanceof rootNode root) {
            for (Node child : root.children) {
                // Write the edge from parent to child
                writer.write(node.Unid + " -> " + child.Unid + ";\n");
                // Recursively process the child node
                generateDOT(child, writer);
            }
        } else if (node instanceof innerNode inner) {
            for (Node child : inner.children) {
                // Write the edge from parent to child
                writer.write(node.Unid + " -> " + child.Unid + ";\n");
                // Recursively process the child node
                generateDOT(child, writer);
            }
        }
    }
    
    static int curGlobVar = 0;
    static Map<Integer, Node> globVarNodes = new HashMap<>();
	
    static int curAssign = 0;
    static Map<Integer, Node> assignNodes = new HashMap<>();
	
    static int curFunction = 0;
    static Map<Integer, Node> functionNodes = new HashMap<>();
    public static void fillTableVariables(Node node) // this table is going to traverse the entire tree and only add variables to the symbol table
    // there are three variable types: num, text, and input
    {
    	// find all GlobVar nodes, and add them to a list
    	// then all ASSIGN nodes, then all FUNCTION nodes
    	// FIRST do GlobVar, THEN function, THEN assign
    	if (node.Symbol.equals("GlobVar"))
    	{
    		System.out.println("GlobVar found.");
    		globVarNodes.put(curGlobVar, node);
    	}
    	else if (node.Symbol.equals("ASSIGN"))
    	{
    		System.out.println("ASSIGN found.");
    		assignNodes.put(curAssign, node);
    	}
    	
    	
    }
    
    public static void symboliseNodes(Node node)
    {
        // Check if this node requires an addition to the symbol table
    	//int id, String name, String type, Object value
    	//System.out.println("Node: "+node.Symbol);
    	if (node instanceof rootNode root) 
    	{
    		//go through all sub-nodes
    		for (Node child : root.children)
    		{
    			symboliseNodes(child);
    		}
    	}
    	else if (node instanceof innerNode inner)
    	{
    		//fill symbol table
    		if (node.Symbol.equals("GlobVar"))
        	{
    			System.out.println("GlobVar:");
        		//find its VTYP child + VNAME child, set those as name and type
        		String type = "";
        		String name = "";
        		for (Node child : inner.children)
        		{
        			if (child.Symbol == "VTYP")
        			{
        				//System.out.println("This node is a VTYP with children "+child.children+" "+child.children.get(0).Symbol);
        				type = child.children.get(0).Symbol;
        			}
        			else if (child.Symbol == "VNAME")
        			{
        				//System.out.println("This node is a VNAME with children "+child.children+" "+child.children.get(0).Symbol);
        				name = child.children.get(0).Symbol;
        			}
        		}
        		System.out.println("\tName: "+name+", Type: "+type);
        		tableTest.addReplaceSymbol(node.Unid, name, type, null);
        	}
    		else if (node.Symbol == "ASSIGN")
        	{
    			System.out.println("ASSIGN:");
    			//find its children; first is variable name, second is either input or =, third is type
    			String name = "";
        		String type = "";
        		Object value = null;
        		name = inner.children.get(0).Symbol;
        		if (inner.children.get(1).Symbol == "=") // assign to a term
        		{
        			System.out.println("\t= type");
        			type = getType(inner.children.get(2));
        		}
        		else // assign is input instead
        		{
        			System.out.println("\tinput type");
        			type = null;
        		}
        		
        		//System.out.println("Name: "+name+". Type: "+type);
        		tableTest.addReplaceSymbol(node.Unid, name, type, null);
        	}
        	else if (node.Symbol == "HEADER") //it's a function
        	{
        		
        	}
    		//then go through all sub-nodes
    		for (Node child : inner.children)
    		{
    			symboliseNodes(child);
    		}
    	}
    	else if (node instanceof leafNode leaf) 
    	{
            //System.out.println("This is a leaf.");
            
    	}
    }
    public static String getType(Node node) // should output the type of a given node, intended for TERM and the like
    // might also need to return the type of a function, rip
    {
    	if (node instanceof leafNode leaf) // node has no children i.e. is a leaf, should only happen when acting on a leaf node
    	{
    		System.out.println("getType: "+node.toString());
    		return classify(node.Symbol);
    	}
    	else //object is not a leaf, thus it is instead a TERM, meaning either
    	/*
    	 * - an ATOMIC (extract its value from its child)
    	 * - a CALL (extract its type from the symbol table or create if necessary
    	 * - an OP (determine type based on the operation)
    	 */
    	{
    		
    	}
		return null;
    }
    
    public static String classify(Object input) //returns a string of the type of the input
    { // should only ever receive either numbers or strings
    	try
    	{
    		int a = Integer.parseInt((String) input);
    		return "num";
    	}
    	catch (Exception e)
    	{
    		return "text";
    	}
    }

    public static void categorizeNodes(Node node, List<innerNode> innerNodes, List<leafNode> leafNodes) {
    	// Check if the current node is an innerNode or a leafNode
        if (node instanceof innerNode inner) {
            // Add to the inner nodes list
            innerNodes.add((innerNode) node);

            // Recursively process its children
            for (Node child : inner.children) {
                categorizeNodes(child, innerNodes, leafNodes);
            }
        } else if (node instanceof leafNode leaf) {
            // Add to the leaf nodes list
            leafNodes.add((leafNode) node);
        }
    }




}
