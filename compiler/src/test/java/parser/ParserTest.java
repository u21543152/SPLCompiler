package parser;

import com.splcompiler.lexer.Token;
import com.splcompiler.parser.*;
import com.splcompiler.symboltable.*;
import com.splcompiler.symboltable.SymbolTable.Symbol;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ParserTest {
	static SymbolTable tableTest = new SymbolTable();
	
    public static void main(String[] args) throws IOException {
    	List<innerNode> innerNodes = new ArrayList<>();
        List<leafNode> leafNodes = new ArrayList<>();

        // Step 1: Read tokens from the XML file
        String lexerOutputFile = "src/main/resources/output.xml";  // This is the XML file generated by the lexer
        List<Token> tokens = lexerXMLParser.readTokensFromXML(lexerOutputFile);

        // Step 2: Parse the tokens to create an AST
        parser parser = new parser(tokens);
        rootNode root = parser.parseProgram();
        System.out.println(root.toXML());
        for (Node child : root.children)
        {
            categorizeNodes(child,innerNodes,leafNodes);
        }

        writeTreeToXML("src/main/resources/syntax_tree.xml",root,innerNodes,leafNodes);
        System.out.println("syntax_tree.xml has been created!");

        // Step 2: Generate DOT file to visualize
        FileWriter writer = new FileWriter("src/main/resources/syntax_tree.dot");

        // Step 3: Write DOT format structure
        writer.write("digraph SyntaxTree {\n");
        generateDOT(root, writer);
        writer.write("}\n");

        writer.close();

        System.out.println("DOT file created! Visualize with Graphviz.");
        
        
        //test symbol table, stage 1
        fillTableGlobVars(root);
        fillTableAssign(root);
        fillTableFunction(root);
        //test symbol table, stage 2
        tableGlobVars();
        tableFunctions();
        //test symbol table, stage 3
        checkAssigns();
        //symboliseNodes(root);
        tableTest.printTable();
        
        //testing getTypeAtomic
        Node rootT = new rootNode(1000, "TEST");
        Node atomicT = new innerNode(1000, "CALL", rootT);
        Node constT = new innerNode(1000, "FNAME", atomicT);
        Node val = new leafNode(999, "F_bara", constT);
        ((innerNode) constT).addChild(val);
        ((innerNode) atomicT).addChild(constT);
        
        System.out.println(getTypeCall(atomicT));
        
    }

    private static void writeTreeToXML(String filePath, rootNode root, List<innerNode> innerNodes, List<leafNode> leafNodes) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
            writer.write(root.toXML());
            writer.write("<INNERNODES>\n");
            for (innerNode node: innerNodes) {
                writer.write(node.toXML());
            }
            writer.write("</INNERNODES>\n");
            writer.write("<LEAFNODES>\n");
            for (leafNode node: leafNodes) {
                writer.write(node.toXML());
            }
            writer.write("</LEAFNODES>\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // Example method to generate the DOT structure
    public static void generateDOT(Node node, FileWriter writer) throws IOException {
        // Write the node's information
        writer.write(node.Unid + " [label=\"" + node.Symbol + "\"];\n");

        // Check if the node has children, write the edges, and recurse for each child
        if (node instanceof rootNode root) {
            for (Node child : root.children) {
                // Write the edge from parent to child
                writer.write(node.Unid + " -> " + child.Unid + ";\n");
                // Recursively process the child node
                generateDOT(child, writer);
            }
        } else if (node instanceof innerNode inner) {
            for (Node child : inner.children) {
                // Write the edge from parent to child
                writer.write(node.Unid + " -> " + child.Unid + ";\n");
                // Recursively process the child node
                generateDOT(child, writer);
            }
        }
    }
    
    static int curGlobVar = 0;
    static Map<Integer, Node> globVarNodes = new HashMap<>();
	
    static int curAssign = 0;
    static Map<Integer, Node> assignNodes = new HashMap<>();
	
    static int curFunction = 0;
    static Map<Integer, Node> functionNodes = new HashMap<>();
    
    public static void fillTableGlobVars(Node node) // this table is going to traverse the entire tree and add GlobVars
    // there are three variable types: num, text, and input
    {
    	//System.out.println(node.Symbol);
    	// find all GlobVar nodes, and add them to a list
    	if (node.Symbol.equals("GlobVar"))
    	{
    		System.out.println("GlobVar found.");
    		globVarNodes.put(curGlobVar, node);
    		curGlobVar++;
    	}
    	
    	for (Node child : node.children)
    	{
    		fillTableGlobVars(child);
    	}
    }
    
    public static void fillTableAssign(Node node) // this table is going to traverse the entire tree and add ASSIGNs
    // there are three variable types: num, text, and input
    {
    	//System.out.println(node.Symbol);
    	// find all ASSIGN nodes, and add them to a list
    	if (node.Symbol.equals("ASSIGN"))
    	{
    		System.out.println("ASSIGN found.");
    		assignNodes.put(curAssign, node);
    		curAssign++;
    	}
    	
    	for (Node child : node.children)
    	{
    		fillTableAssign(child);
    	}
    }
    
    public static void fillTableFunction(Node node) // this table is going to traverse the entire tree and add functions
    {
    	//System.out.println(node.Symbol);
    	// find all DECL nodes, and add them to a list
    	if (node.Symbol.equals("DECL"))
    	{
    		System.out.println("DECL found.");
    		functionNodes.put(curFunction, node);
    		curFunction++;
    	}
    	
    	for (Node child : node.children)
    	{
    		fillTableFunction(child);
    	}
    }
    
    public static void tableGlobVars() // this function adds all GlobVars to the symbol table
    {
    	for (Node cur : globVarNodes.values())
    	{
    		String type = "";
    		String name = "";
    		for (Node child : cur.children)
    		{
    			if (child.Symbol == "VTYP")
    			{
    				//System.out.println("This node is a VTYP with children "+child.children+" "+child.children.get(0).Symbol);
    				type = child.children.get(0).Symbol;
    			}
    			else if (child.Symbol == "VNAME")
    			{
    				//System.out.println("This node is a VNAME with children "+child.children+" "+child.children.get(0).Symbol);
    				name = child.children.get(0).Symbol;
    			}
    		}
    		//System.out.println("\tName: "+name+", Type: "+type);
    		tableTest.addReplaceSymbol(cur.Unid, name, type, null);
    	}
    }
    
    public static void tableFunctions() // this function adds all functions to the symbol table
    {
    	for (Node cur : functionNodes.values()) // "cur" now represents a single DECL node
    	{
    		Node cur2 = cur.children.get(0); // "cur2" now represents a single HEADER node
    		System.out.println("  cur2: "+cur2.Symbol);
    		//find its FTYP child + FNAME child, set those as name and type, add to table
    		String type = "";
    		String name = "";
    		for (Node child : cur2.children)
    		{
    			if (child.Symbol == "FTYP")
    			{
    				type = child.children.get(0).Symbol;
    			}
    			else if (child.Symbol == "FNAME")
    			{
    				name = child.children.get(0).Symbol;
    			}
    		}
    		tableTest.addReplaceSymbol(cur.Unid, name, type, null);
    		tableLocVars(cur);
    	}
    }
    
    public static void tableLocVars(Node node) // this function adds all local variables of a function to the symbol table
    // "node" stores a DECL node
    {
    	Node locVars = node.children.get(1).children.get(1); // retrieves the LOCVARS node
    	int id1 = locVars.children.get(0).Unid;
    	int id2 = locVars.children.get(2).Unid;
    	int id3 = locVars.children.get(4).Unid;
    	tableTest.addReplaceSymbol(id1, locVars.children.get(1).Symbol, locVars.children.get(0).Symbol, null); // add local var 1
    	tableTest.addReplaceSymbol(id2, locVars.children.get(3).Symbol, locVars.children.get(2).Symbol, null); // add local var 2
    	tableTest.addReplaceSymbol(id3, locVars.children.get(5).Symbol, locVars.children.get(4).Symbol, null); // add local var 3
    }

    public static void checkAssigns()
    {
    	for (Node cur : assignNodes.values())
    	{
    		if (cur.children.get(1).Symbol == "< input") //assign is to user input, add a warning
    		{
    			Symbol current = tableTest.getSymbolByName(cur.children.get(0).Symbol); //retrieve the symbol from the table
    			current.setNote("WARN: Value set by user input, which must match type ("+current.getType()+") or risk a type mismatch.");
    		}
    		else if (cur.children.get(1).Symbol == "=")
    		//assign is to a TERM, aka an ATOMIC, a CALL, or an OP
    		//- ATOMIC is VNAME or CONST
    		//- CALL is to a function
    		//- OP is to UNOP or BINOP
    		{
    			Symbol current = tableTest.getSymbolByName(cur.children.get(0).Symbol); //retrieve the symbol from the table
    			switch (cur.children.get(2).Symbol)
    			{
    			case "ATOMIC":
    				String type = getTypeAtomic(cur.children.get(2));
    				if (current.getType() == type)
    				{
    					tableTest.addReplaceSymbol(cur.children.get(2).Unid, current.getName(), type, null);
    				}
    				else
    				{
    					tableTest.addReplaceSymbol(cur.children.get(2).Unid, current.getName(), type, "WARN: Type violation (new type "+type+", was "+current.getType()+")");
    				}
    			case "CALL":
    				String type2 = getTypeCall(cur.children.get(2));
    				if (current.getType() == type2)
    				{
    					tableTest.addReplaceSymbol(cur.children.get(2).Unid, current.getName(), type2, null);
    				}
    				else
    				{
    					tableTest.addReplaceSymbol(cur.children.get(2).Unid, current.getName(), type2, "WARN: Type violation (new type "+type2+", was "+current.getType()+")");
    				}
    			case "OP":
    				
    				
    			}
    		}
    		else
    		{
    		
    		}
    	}
    }
    
    public static String getTypeAtomic(Node node) //gets the type of an ATOMIC node, aka either a VNAME or a CONST
    //'node' is the ATOMIC node
    {
    	String type = "ERROR";
    	if (node.children.get(0).Symbol == "VNAME") //ATOMIC is a variable that exists; get type from symbol table
    	{
    		String name = node.children.get(0).children.get(0).Symbol;
    		type = tableTest.getSymbolByName(name).getType();
    	}
    	else if (node.children.get(0).Symbol == "CONST") //ATOMIC is a constant: infer its type
    	{
    		try
    		{
    			int val = -29839;
    			val = Integer.parseInt(node.children.get(0).children.get(0).Symbol);
    			if (val != -29839)
    			{
    				type = "num";
    			}
    		}
    		catch (Exception e)
    		{
    			type = "text";
    		}
    	}
    	
    	return type;
    }
    
    public static String getTypeCall(Node node) //gets the type of a CALL node, aka the type of its function
    //'node' is the CALL node
    {
    	String type = "ERROR";
    	String name = node.children.get(0).children.get(0).Symbol; // Symbol of the child of first child, aka symbol of FNAME, aka function name
    	try
    	{
        	type = tableTest.getSymbolByName(name).getType();
    	}
    	catch (Exception e)
    	{
    		
    	}
    	return type;
    }
    
    //public static String getTypeOp(Node node) //gets the type of an OP node, which must be inferred from its arguments
    //'node' is the OP node, this may involve recursion
    {
    	/* UNOP
    	 * - not is only valid for or, and, eq, and grt
    	 * - sqrt is only valid for two 
    	 */
    }
    
    public static String getTypeArg(Node node) //gets the type of an ARG node, which must be inferred from its children
    //'node' is the ARG node, this may involve recursion
    {
    	if (node.children.get(0).Symbol == "ATOMIC")
    	{
    		return getTypeAtomic(node.children.get(0));
    	}
    	else if (node.children.get(0).Symbol == "OP")
    	{
    		return "ERROR";
    		//return getTypeOp(node.children.get(0));
    	}
    	else
    	{
    		return "ERROR";
    	}
    }
   
    public static void categorizeNodes(Node node, List<innerNode> innerNodes, List<leafNode> leafNodes) {
    	// Check if the current node is an innerNode or a leafNode
        if (node instanceof innerNode inner) {
            // Add to the inner nodes list
            innerNodes.add((innerNode) node);

            // Recursively process its children
            for (Node child : inner.children) {
                categorizeNodes(child, innerNodes, leafNodes);
            }
        } else if (node instanceof leafNode leaf) {
            // Add to the leaf nodes list
            leafNodes.add((leafNode) node);
        }
    }




}
