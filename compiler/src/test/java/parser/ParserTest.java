package parser;

import com.splcompiler.lexer.Token;
import com.splcompiler.parser.*;
import com.splcompiler.symboltable.*;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class ParserTest {
	static SymbolTable tableTest = new SymbolTable();
	
    public static void main(String[] args) throws IOException {
    	List<innerNode> innerNodes = new ArrayList<>();
        List<leafNode> leafNodes = new ArrayList<>();

        // Step 1: Read tokens from the XML file
        String lexerOutputFile = "src/main/resources/output.xml";  // This is the XML file generated by the lexer
        List<Token> tokens = lexerXMLParser.readTokensFromXML(lexerOutputFile);

        // Step 2: Parse the tokens to create an AST
        parser parser = new parser(tokens);
        rootNode root = parser.parseProgram();
        System.out.println(root.toXML());
        for (Node child : root.children)
        {
            categorizeNodes(child,innerNodes,leafNodes);
        }

        writeTreeToXML("src/main/resources/syntax_tree.xml",root,innerNodes,leafNodes);
        System.out.println("syntax_tree.xml has been created!");

        // Step 2: Generate DOT file to visualize
        FileWriter writer = new FileWriter("src/main/resources/syntax_tree.dot");

        // Step 3: Write DOT format structure
        writer.write("digraph SyntaxTree {\n");
        generateDOT(root, writer);
        writer.write("}\n");

        writer.close();

        System.out.println("DOT file created! Visualize with Graphviz.");
        
        
        //test symbol table
        symboliseNodes(root);
        tableTest.printTable();
    }

    private static void writeTreeToXML(String filePath, rootNode root, List<innerNode> innerNodes, List<leafNode> leafNodes) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
            writer.write(root.toXML());
            writer.write("<INNERNODES>\n");
            for (innerNode node: innerNodes) {
                writer.write(node.toXML());
            }
            writer.write("</INNERNODES>\n");
            writer.write("<LEAFNODES>\n");
            for (leafNode node: leafNodes) {
                writer.write(node.toXML());
            }
            writer.write("</LEAFNODES>\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // Example method to generate the DOT structure
    public static void generateDOT(Node node, FileWriter writer) throws IOException {
        // Write the node's information
        writer.write(node.Unid + " [label=\"" + node.Symbol + "\"];\n");

        // Check if the node has children, write the edges, and recurse for each child
        if (node instanceof rootNode root) {
            for (Node child : root.children) {
                // Write the edge from parent to child
                writer.write(node.Unid + " -> " + child.Unid + ";\n");
                // Recursively process the child node
                generateDOT(child, writer);
            }
        } else if (node instanceof innerNode inner) {
            for (Node child : inner.children) {
                // Write the edge from parent to child
                writer.write(node.Unid + " -> " + child.Unid + ";\n");
                // Recursively process the child node
                generateDOT(child, writer);
            }
        }
    }
    
    public static void symboliseNodes(Node node)
    {
        // Check if this node requires an addition to the symbol table
    	//int id, String name, String type, Object value
    	System.out.println("Node: "+node.Symbol);
    	if (node instanceof rootNode root) 
    	{
    		//go through all sub-nodes
    		for (Node child : root.children)
    		{
    			symboliseNodes(child);
    		}
    	}
    	else if (node instanceof innerNode inner)
    	{
    		//fill symbol table
    		if (node.Symbol.equals("GlobVar"))
        	{
        		//find its VTYP child + VNAME child, set those as name and type
        		String type = "";
        		String name = "";
        		for (Node child : inner.children)
        		{
        			if (child.Symbol == "VTYP")
        			{
        				//System.out.println("This node is a VTYP with children "+child.children+" "+child.children.get(0).Symbol);
        				type = child.children.get(0).Symbol;
        			}
        			else if (child.Symbol == "VNAME")
        			{
        				//System.out.println("This node is a VNAME with children "+child.children+" "+child.children.get(0).Symbol);
        				name = child.children.get(0).Symbol;
        			}
        		}
        		System.out.println("Name: "+name+". Type: "+type);
        		tableTest.addReplaceSymbol(node.Unid, name, type, null);
        	}
    		/*
    		else if (node.Symbol == "ASSIGN")
        	{
        		System.out.println("Node: "+node.Symbol);
        		//find its VTYP child + VNAME child, set those as name and type
        		String type = "";
        		String name = "";
        		for (Node child : inner.children)
        		{
        			if (child.Symbol == "VTYP")
        			{
        				type = child.children.get(0).Symbol;
        			}
        			else if (child.Symbol == "VNAME")
        			{
        				name = child.children.get(0).Symbol;
        			}
        		}
        		tableTest.addReplaceSymbol(node.Unid, name, type, null);
        	}
        	else if (node.Symbol == "HEADER")
        	{
        		
        	}*/
    		//then go through all sub-nodes
    		for (Node child : inner.children)
    		{
    			symboliseNodes(child);
    		}
    	}
    	else if (node instanceof leafNode leaf) 
    	{
            //System.out.println("This is a leaf.");
            
    	}
    }

    public static void categorizeNodes(Node node, List<innerNode> innerNodes, List<leafNode> leafNodes) {
    	// Check if the current node is an innerNode or a leafNode
        if (node instanceof innerNode inner) {
            // Add to the inner nodes list
            innerNodes.add((innerNode) node);

            // Recursively process its children
            for (Node child : inner.children) {
                categorizeNodes(child, innerNodes, leafNodes);
            }
        } else if (node instanceof leafNode leaf) {
            // Add to the leaf nodes list
            leafNodes.add((leafNode) node);
        }
    }




}
